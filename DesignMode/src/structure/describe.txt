结构模式
   代理模式：为其他对象提供一种代理以控制对这个对象的访问.
     静态代理：静态代理用的少，需要让代理对象实现被代理对象的接口，然后包装代理对象，不灵活，而且多一个方法就要重写一遍
     动态代理 ： 
      jdk动态代理：利用拦截器(拦截器必须实现InvocationHanlder)加上反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理（必须要有接口）
      cglib动态代理：利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理
      Spring的AOP实现中，即采用的动态代理，而且jdk和cglib是可以动态选择的。
               若bean对象实现了接口，则采用JDK动态代理，若没有实现，则采用cglib动态代理，也可以强制选择cglib，效率上，现在的jdk版本基本优于cglib。

  适配器模式：两个不兼容的类一起使用，这时候就需要通过适配器来进行转化，使得两者互相匹配  
  
   外观模式：将子系统的一系列操作做一个封装，只暴露一个简单通用的接口在外面，避免客户端过于复杂的调用。 
    